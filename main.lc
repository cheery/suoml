import grammar
import types

# TODO: Start catching comments from this file and create .md file out of them.
# TODO: Some simple arithmetic, maybe the fibonacci and such..
# TODO: Figure out machinery for declaring new abstract datatypes.

# The SCC finding is likely necessary for handling recursion.
from graph_utils import
    tarjan_find_scc,
    greedy_biclique_decomposition

t_string   = types.SimpleHeader('string')
t_int      = types.SimpleHeader('int')
t_rational = types.SimpleHeader('rational')

t_unit = types.SimpleHeader('unit')


language = grammar.read_file("suoml.grammar")

main = ():
    actions = object({
        def = Def
        app = App
        let = Let
        abs = Abs
        if_then_else = IfThenElse
        var = Var
        string = (val):
            return Lit(val, t_string)
        int = (val):
            return Lit(val, t_int)
        rational = (val):
            return Lit(val, t_rational)
    })
    parse = language.read_file("sample.fml")
    decls = parse.traverse((rule, args, loc):
        return getattr(actions, rule)(args...))

    declared = {}

    # We could use builtin function header here without
    # causing any issues, since we can use simple headers to
    # illustrate this system, we do so.
    f = types.State(+1)
    z = types.State(-1)
    r = types.State(+1)
    z.heads.add(t_string)
    r.heads.add(t_unit)
    f.heads.add(types.get_function_header(1))
    f.add_transition(types.dom[0], z)
    f.add_transition(types.cod, r)
    declared['print'] = generalize(f, null)

    f = types.State(+1)
    f.heads.add(types.t_call)
    declared['call'] = generalize(f, null)


    namespace = {}
    for decl in decls
        namespace[decl.name] = decl

    dependency_graph = {}
    for decl in decls
        dependencies = set()
        for name in scan_free_vars(decl)
            if name in namespace
                dependencies.add(name)
            elif name not in declared
                assert false, ["not present", name]
        dependency_graph[decl.name] = dependencies

    scc = tarjan_find_scc(dependency_graph)

    for group in scc
        is_rec = group_is_recursive(group, dependency_graph)
        new_types = infer_group(declared, group, is_rec, namespace)
        declared.update(new_types)

    for name, scheme in declared.items()
        print(name, "::", to_raw_type(scheme))

scan_free_vars = (a):
    if isinstance(a, Def)
        free = scan_free_vars(a.body)
        free.difference_update(a.args)
        return free
    if isinstance(a, Abs)
        free = scan_free_vars(a.body)
        for arg in a.args
            free.discard(arg)
        return free
    if isinstance(a, App)
        free = scan_free_vars(a.lhs)
        for arg in a.args
            free.update(scan_free_vars(arg))
        return free
    if isinstance(a, Var)
        return set([a.name])
    if isinstance(a, Lit)
        return set()
    if isinstance(a, Let)
        free = scan_free_vars(a.rhs)
        free.discard(a.name)
        free.update( scan_free_vars(a.lhs) )
        return free
    if isinstance(a, IfThenElse)
        free = scan_free_vars(a.cond)
        free.update(scan_free_vars(a.t))
        free.update(scan_free_vars(a.f))
        return free
    assert false, ["free vars for?", a]

group_is_recursive = (group, dependency_graph):
    if group.length == 1
        name = list(group)[0]
        return name in dependency_graph[name]
    else
        return true

# First create scope with blank variables
# Next do inference as usual, the biunification associates the signature
# with the previous blank variable.
# Finally the variables end up being correctly generalized, and
# it yields polymorphic types for declarations.
infer_group = (predeclared, group, recursive, namespace):
    env = TypeEnv(predeclared, null)
    visited = set()
    result = {}
    if recursive
        ports = {}
        for name in group
            ports[name] = port = types.new_port(env.free)
            env.schemes[name] = generalize(port.output, env)
             
        for name in group
            port = ports[name]
            decl = namespace[name]
            scheme = infer(Abs(decl.args, decl.body), env, visited)
            types.biunify([scheme.root, port.input], visited)

        for name in group
            port = ports[name]
            result[name] = generalize(port.output, null)
    else
        for name in group
            decl = namespace[name]
            scheme = infer(Abs(decl.args, decl.body), env, visited)
            result[name] = generalize(scheme.root, null)
    return result

# THE STRUCTURE OF TYPE ENV
# parent  : type_env
# free    : set(State)
#   The set of states that are free in this type env.
#   Nodes must be removed from this env if they become free in parent.
# schemes : {generic: set(State), root: State}
#   'generic' are generic parts of the binding. They *must* not be reachable
#   from any 'free' set.
#   'root' is the root state of the type.
class TypeEnv
    +init = (self, schemes, parent):
        self.schemes = schemes
        self.parent = parent
        self.free = set()

    +getitem = (self, name):
        try
            scheme = self.schemes[name]
            return scheme
        except KeyError as ke
            raise ke if not self.parent
            return self.parent[name]

infer = (a, env, visited):
    if isinstance(a, Abs)
        a_env = TypeEnv({}, env)
        ports = []
        for arg in a.args
            port = types.new_port(a_env.free)
            ports.append(port)
            a_env.schemes[arg] = generalize(port.output, a_env)
        a_scheme = infer(a.body, a_env, visited)

        functype = types.State(+1)
        functype.heads.add(types.get_function_header(ports.length))
        for i in range(ports.length)
            functype.add_transition(types.dom[i], ports[i].input)
        functype.add_transition(types.cod, a_scheme.root)
        return (root=functype)

    if isinstance(a, App)
        lhs_scheme = infer(a.lhs, env, visited)

        op_site = types.new_operator(types.t_call, [0],
            1 + a.args.length)
        sink = types.new_port()
        sink.input.heads.add(types.SinkHeader(0, op_site))

        calltype = types.State(-1)
        calltype.heads.add(op_site.expect)
        calltype.add_transition(types.dom[0], sink.output)
        i = 1
        for arg in a.args
            arg_scheme = infer(arg, env, visited)
            calltype.add_transition(types.dom[i], arg_scheme.root)
            i += 1
        result = types.new_port()

        calltype.add_transition(types.cod, result.input)
        sink.input.add_transition(op_site.edge, calltype)

        types.biunify([lhs_scheme.root, sink.input], visited)

        return (root=result.output)

    if isinstance(a, Var)
        a_scheme = instantiate_type(env[a.name])
        return a_scheme

    if isinstance(a, Lit)
        result = types.State(+1)
        result.heads.add(a.type)
        return (root=result)

    if isinstance(a, IfThenElse)
        cond = infer(a.cond, env, visited)

        boolean = Node(-1)
        boolean.heads.add(bool_t)

        biunify([cond.root, boolean], visited)
        t = infer(a.t, env, visited)
        f = infer(a.f, env, visited)

        result = new_port()
        biunify([t.root, result.input], visited)
        biunify([f.root, result.input], visited)

        return (root=result.output)

    if isinstance(a, Let)
        lhs_scheme = inference(a.lhs, env, visited)

        a_env = TypeEnv(env)
        a_env.schemes[a.name] = generalize(lhs_scheme.root, env)
        rhs_scheme = inference(a.rhs, a_env, visited)

        return (root=rhs_scheme.root)

    assert false, ["implement infer(a)", a]

# Remember that for subtyping, type variables represent flows.
# This means that only-covariant or only-contravariant type variables
# do not really convey useful information.
to_raw_type = (scheme):
    flow_variables = greedy_biclique_decomposition(
        scheme.generic,
        (vertex):
            return vertex.flow)

    visi = set()
    mapi = {}
    rvar_id = 0

    trail = set()

    s_visit = (state):
        assert state in scheme.generic
        if state in visi
            sym = "rec.r" ++ (rvar_id).to_string()
            mapi[state] = "let.r" ++ (rvar_id).to_string()
            rvar_id += 1
            return sym
        visi.add(state)

        if state.pol > 0
            operator = " | "
        else
            operator = " & "

        typedecl = []
        for head in state.heads
            # TODO: Sink headers should get different treatment,
            #       For now we hide them.
            if isinstance(head, types.SinkHeader)
                name = repr(head.site.op)
                trail.add("\n  " ++ name ++ " : " ++
                    e_visit(state, head.site.edge))
                if name not in typedecl
                    typedecl.append(name)
                continue
            typedecl.append(r_visit(head, state))
        for v in flow_variables[state]
            typedecl.append("a" ++ (v).to_string())

        if state in mapi
            typedecl.insert(0, mapi.pop(state))
        visi.discard(state)
        return "(" ++ operator.join(typedecl) ++ ")"

    r_visit = (head, state):
        px = {}
        for edge in head.params()
            px[edge] = e_visit(state, edge)
        return head.stringify(px)

    e_visit = (state, edge):
        if edge not in state.transitions
            return "(error)"
        ws = state.transitions[edge]
        if ws.length == 0
            return "()"
        assert ws.length == 1, "not a reduced type form"
        w = list(ws)[0]
        return s_visit(w)

    return s_visit(scheme.root) ++ "".join(trail)

# The generalize recalculates the 'free' state sets in the environment by
# extending it. Then it runs a subset construction that takes everything
# not in 'free' and constructs a new graph. 'generic' ends up labeling the
# states present in this new sub-graph.
generalize = (root, env):
    recalculate_free = (env):
        if env == null
            return set()
        free = recalculate_free(env.parent)
        # Nodes free in parent do not need to appear in free set
        env.free.difference_update(free)

        visit = (state):
            if state not in free
                env.free.add(state)

        # type_env.free fills up while this is going on.
        for state in env.free
            for w in state.flow
                visit(w)
            for edge, ws in state.transitions.items()
                for w in ws
                    visit(w)

        free.update(env.free)
        return free
    free = recalculate_free(env)


    # subsets : {set(Node) : Node}
    # membership : {Node : set(Node)}
    subsets = {}
    membership = {}

    reduce_site_port = (port):
        return reduce_subset(port.pol, set([port]))
    reduce_subset = (pol, subset):
        if subset in subsets
            return subsets[subset]
        subsets[subset] = s = types.State(pol)
        rw_edge = {}
        for n in subset
            assert n not in free, "bug: subset must not contain free states"
            for head in n.heads
                if isinstance(head, types.SinkHeader)
                    site = head.site.transfer(reduce_site_port)
                    rw_edge[head.site.edge] = site.edge
                    head = types.SinkHeader(head.index, site)
                s.heads.add(head)
            try
                membership[n].append(s)
            except KeyError as _
                membership[n] = [s]
            for edge, ws in n.transitions.items()
                for w in ws
                    s.add_transition(edge, w)

        transitions = {}
        for edge, ws in s.transitions.items()
            edge = rw_edge.get(edge, edge)
            extern = set()
            for w in ws
                if w in free
                    extern.add(w)
            ws.difference_update(extern)
            transitions[edge] = set([reduce_subset(pol*edge.pol, ws)]) | extern
        s.transitions = transitions
        return s

    if root in free
        return (generic=set(), root=root)
    root = reduce_subset(root.pol, set([root]))
    for state, ss in membership.items()
        continue if state.pol > 0
        for w in state.flow
            assert w not in free, "bug: free state that is not marked free"
            qq = membership.get(w, [])
            for s in ss
                for q in qq
                    s.add_flow(q)
    return (generic=set(subsets.values()), root=root)

instantiate_type = (scheme):
    mapping = {}
    copy_state = (n):
        return n if n not in scheme.generic
        try
            return mapping[n]
        except KeyError as _
            mapping[n] = m = types.State(n.pol)
            rw_edge = {}
            for head in n.heads
                if isinstance(head, types.SinkHeader)
                    site = head.site.transfer(copy_state)
                    rw_edge[head.site.edge] = site.edge
                    head = types.SinkHeader(head.index, site)
                m.heads.add(head)
            for w in n.flow
                m.flow.add(copy_state(w))
            for edge, ws in n.transitions.items()
                edge = rw_edge.get(edge, edge)
                for w in ws
                    m.add_transition(edge, copy_state(w))
            return m
    root = copy_state(scheme.root)
    return (root=root)

class Def
    +init = (self, name, args, body):
        self.name = name
        self.args = args
        self.body = body

class App
    +init = (self, lhs, args):
        self.lhs = lhs
        self.args = args

class Let
    +init = (self, name, lhs, rhs):
        self.name = name
        self.lhs = lhs
        self.rhs = rhs

class Abs
    +init = (self, args, body):
        self.args = args
        self.body = body

class IfThenElse
    +init = (self, cond, t, f):
        self.cond = cond
        self.t = t
        self.f = f

class Var
    +init = (self, name):
        self.name = name

class Lit
    +init = (self, value, type):
        self.value = value
        self.type = type
