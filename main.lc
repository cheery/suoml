import grammar

language = grammar.read_file("suoml.grammar")

main = ():
    parse = language.read_file("sample.fml")
    decls = parse.traverse((rule, args, loc):
        return getattr(actions, rule)(args...))

    # Assuming that the subtyping algorithm is going to require a similar
    # treatment as the Algorithm W in order to handle recursive clauses
    # correctly. Therefore this builds the dependency graph so that the
    # SCC algorithm then sort the expressions out.
    decl_by_name = {}
    for decl in decls
        decl_by_name[decl.name] = decl
    for decl in decls
        for name in decl.free_vars
            if name in decl_by_name
                decl.depends.add(decl_by_name[name])

    out = tarjan_find_scc(decls)
    for group in out
        if group.length != 1
            print("Error: not ready for recursive definitions yet")
            print("SCC detected:")
            for decl in group
                print(" ", decl)
            exit(1)


        type_env = {}

        # TODO: Ready for type inference.
        decl = group.pop()
        inference(Abs(decl.args, decl.body), type_env)

    mapping = {}
    node_to_name = (node):
        try
            return mapping[node]
        except KeyError as _
            vname = mapping.length.to_string(35) + 10
            mapping[node] = vname
            return vname

    # http://www.graphviz.org/doc/info/attrs.html
    lines = []
    # "p -> q [dir=none];" is biunification
    # "p -> q" is flow edge.

    print("digraph inference {\n" ++ "\n".join(lines) ++ "\n}")

inference = (a, type_env):
    if isinstance(a, Abs)
        type_env = dict(type_env)
        ports = []
        for arg in a.args
            port = new_port()
            ports.append(port)
            type_env[arg] = port.output
        return inference(a.body, type_env)

    assert false, a



new_port = ():
    input = Node(-1)
    output = Node(+1)
    input.add_flow(output)
    return (input=input, output=output)

class Node
    +init = (self, pol=+1):
        self.pol = pol
        self.heads = set()
        self.flow = set()
        self.p_transitions = {}
        self.n_transitions = {}

    add_flow = (self, other):
        assert self.pol != other.pol
        self.flow.add(other)
        other.flow.add(self)

    add_transition = (self, label, port):
        if port.pol == self.pol
            transitions = self.p_transitions
        else
            transitions = self.n_transitions
        try
            self.transitions[label].add(port)
        except KeyError as _
            self.transitions[label] = set([port])

merge = (dst, src):
    assert dst.pol == src.pol
    for head in src.heads
        dst.heads.add(head)
    for v in src.flow
        dst.add_flow(v)
    for label, vs in src.p_transitions.items()
        try
            dst.p_transitions[label].update(vs)
        except KeyError as _
            dst.p_transitions[label] = set(vs)
    for label, vs in src.n_transitions.items()
        try
            dst.n_transitions[label].update(vs)
        except KeyError as _
            dst.n_transitions[label] = set(vs)

biunify = (pair, visited):
    return if pair in visited
    visited.add(pair)
    p, q = pair
    assert p.pol > q.pol, "biunify must have form (+p, -q)"

    # Check that subtyping constraints hold
    for x in p.heads
        for y in q.heads
            assert is_subtype(x, y), ["type error", x, y]

    # Rewrites the graph, eliminating the constraint
    for s in q.flow
        merge(s, p)
    for s in p.flow
        merge(s, q)

    # Constraint decomposition
    for label, ss in p.p_transitions.items()
        uu = q.p_transitions.get(label, [])
        for s in ss
            for u in uu
                biunify([s,u], visited)
    for label, ss in p.n_transitions.items()
        uu = q.n_transitions.get(label, [])
        for u in uu
            for s in ss
                biunify([u,s], visited)





# The SCC finding is likely necessary for handling recursion.
# For now we use it to detect recursion so it fails before causing issues.
# https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
# TODO: improve the comments to explain the algorithm.
tarjan_find_scc = (decls):
    index = 0
    s = []
    output = []

    strong_connect = (decl):
        # set depth index for v to the smallest unused index
        decl.index = index
        decl.lowlink = index
        index += 1
        s.append(decl)
        decl.on_stack = true

        # consider successors of v
        for w in decl.depends
            if w.index == null # successor not visited yet
                strong_connect(w)
                decl.lowlink = min(decl.lowlink, w.lowlink)
            elif w.on_stack
                # successor w is in stack S, in the current SCC
                # Note: The next line may look odd - but is correct.
                # It says w.index not w.lowlink; that is deliberate and from the original paper
                decl.lowlink = min(decl.lowlink, w.index)
            # if w is not on stack, then (v,w) is a cross-edge in the DFS and
            #    must be ignored.
        # If v is a root node, pop the stack and generate an SCC
        if decl.lowlink == decl.index
            scc = set()
            w = null
            while w != decl
                w = s.pop()
                w.on_stack = false
                scc.add(w)
            output.append(scc)

    for decl in decls
        if decl.index == null
            strong_connect(decl)
    return output

class Def
    +init = (self, name, args, body):
        self.name = name
        self.args = args
        self.body = body
        self.free_vars = free_vars(body)
        self.depends = set()

        # For tarjan find SCC
        self.index = null
        self.lowlink = null
        self.on_stack = false

    +repr = (self):
        return repr(["Def", self.name, self.args, self.body])

free_vars = (a):
    if isinstance(a, Let)
        r = free_vars(a.rhs)
        r.discard(a.name)
        r.update( free_vars(a.lhs) )
        return r
    if isinstance(a, Abs)
        r = free_vars(a.body)
        for arg in a.args
            r.discard(arg)
        return r
    if isinstance(a, App)
        r = free_vars(a.lhs)
        for arg in a.args
            r.update(free_vars(arg))
        return r
    if isinstance(a, Var)
        return set([a.name])
    if isinstance(a, Lit)
        return set()
    assert false, ["free vars for?", a]

class Let
    +init = (self, name, lhs, rhs):
        self.name = name
        self.lhs = lhs
        self.rhs = rhs

    +repr = (self):
        return repr(["Let", self.name, self.lhs, self.rhs])

class Abs
    +init = (self, args, body):
        self.args = args
        self.body = body

    +repr = (self):
        return repr(["Abs", self.args, self.body])

class App
    +init = (self, lhs, args):
        self.lhs = lhs
        self.args = args

    +repr = (self):
        return repr(["App", self.lhs, self.args])

class Var
    +init = (self, name):
        self.name = name

    +repr = (self):
        return self.name

class Lit
    +init = (self, value, type):
        self.value = value
        self.type = type

    +repr = (self):
        return repr(["Lit", self.value, self.type])

actions = object({
    def = Def
    let = Let
    abs = Abs
    app = App
    var = Var
    string = (val):
        return Lit(val, "string")
    int = (val):
        return Lit(val, "int")
})
